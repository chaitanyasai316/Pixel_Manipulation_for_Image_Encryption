#include <stdio.h>
#include <stdlib.h>

// Structure to store RGB values for each pixel
typedef struct {
    unsigned char r, g, b;
} Pixel;

// Function to read BMP image file
Pixel* read_image(const char *filename, int *width, int *height, int *padding) {
    // Open the file in binary read mode
    FILE *file = fopen(filename, "rb");
    if (!file) {
        printf("Error: Unable to open file %s\n", filename);
        return NULL;
    }

    // Read BMP file header
    unsigned char header[54];
    fread(header, sizeof(unsigned char), 54, file);

    // Extract width and height from header
    *width = *(int*)&header[18];
    *height = *(int*)&header[22];

    // Calculate padding (BMP rows must be a multiple of 4 bytes)
    *padding = (*width * 3) % 4;

    // Allocate memory for image pixels (width * height pixels)
    int size = (*width) * (*height);
    Pixel *pixels = (Pixel*)malloc(size * sizeof(Pixel));

    // Read pixel data row by row (consider padding)
    for (int i = 0; i < *height; i++) {
        fread(&pixels[i * (*width)], sizeof(Pixel), *width, file);
        fseek(file, *padding, SEEK_CUR);  // Skip padding bytes
    }

    fclose(file);
    return pixels;
}

// Function to write BMP image file
void write_image(const char *filename, Pixel *pixels, int width, int height, int padding) {
    // Open the file in binary write mode
    FILE *file = fopen(filename, "wb");
    if (!file) {
        printf("Error: Unable to save file %s\n", filename);
        return;
    }

    // Create and write BMP file header
    unsigned char header[54] = {
        0x42, 0x4D, // Signature
        0, 0, 0, 0, // File size
        0, 0, 0, 0, // Reserved
        54, 0, 0, 0, // Data offset
        40, 0, 0, 0, // Header size
        0, 0, 0, 0, // Width
        0, 0, 0, 0, // Height
        1, 0, 24, 0, // Planes and bits per pixel
        0, 0, 0, 0, // Compression
        0, 0, 0, 0, // Image size
        0, 0, 0, 0, // Horizontal resolution
        0, 0, 0, 0, // Vertical resolution
        0, 0, 0, 0, // Number of colors
        0, 0, 0, 0  // Important colors
    };

    // Set width and height in header
    *(int*)&header[18] = width;
    *(int*)&header[22] = height;

    // Calculate file size
    int fileSize = 54 + (width * height * 3) + (padding * height);
    *(int*)&header[2] = fileSize;

    // Write header
    fwrite(header, sizeof(unsigned char), 54, file);

    // Write pixel data row by row, adding padding for each row
    for (int i = 0; i < height; i++) {
        fwrite(&pixels[i * width], sizeof(Pixel), width, file);
        for (int j = 0; j < padding; j++) {
            fputc(0, file);  // Write padding bytes
        }
    }

    fclose(file);
}

// Function to encrypt or decrypt the image by applying a basic mathematical operation
void encrypt_decrypt_image(Pixel *pixels, int width, int height, int key, int mode) {
    int size = width * height;
    for (int i = 0; i < size; i++) {
        // Apply encryption/decryption by adding or subtracting the key
        if (mode == 1) {
            pixels[i].r = (pixels[i].r + key) % 256;
            pixels[i].g = (pixels[i].g + key) % 256;
            pixels[i].b = (pixels[i].b + key) % 256;
        } else {
            pixels[i].r = (pixels[i].r - key + 256) % 256;
            pixels[i].g = (pixels[i].g - key + 256) %
